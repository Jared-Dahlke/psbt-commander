   
    // pub fn create_psbt_and_broadcast(
    //     CreatePsbtInput { descriptor, amount, recipient }: CreatePsbtInput
    // ){
    //     let wallet = BdkWallet::create_wallet(descriptor)?;
        
    //     let dest_script = bdk::bitcoin::Address::from_str(recipient); // .script_pubkey();
    //     let dest_script = match dest_script {
    //         Ok(script) => script.script_pubkey(),
    //         Err(_) => return Err(bdk::Error::Generic("Invalid address".to_string())),
    //     };

    //     let mut tx_builder = wallet.build_tx().coin_selection(DefaultCoinSelectionAlgorithm::default());

    //     //  // The Coldcard requires an output redeem witness script
    //     tx_builder.include_output_redeem_witness_script();

    //     // // Enable signaling replace-by-fee
    //     tx_builder.enable_rbf();

    //     // // Add our script and the amount in sats to send
    //     tx_builder.add_recipient(dest_script, amount);

    //     // "Finish" the builder which returns a tuple:
    //     // A `PartiallySignedTransaction` which serializes as a psbt
    //     // And `TransactionDetails` which has helpful info about the transaction we just built
    //      let (mut psbt, details) = tx_builder.finish()?;

    //      // temporary, going to go ahead and sign and broadcast here:
    //     let signed = wallet.sign(&mut psbt, SignOptions::default())?;
    //     let tx = psbt.extract_tx();

    //     // Broadcast the transaction using our chosen backend, returning a `Txid` or an error
    //     let client = Client::new("tcp://localhost:50000")?;
    //     let blockchain = ElectrumBlockchain::from(client);
    //     let txid = blockchain.broadcast(&tx)?;
  
    //     println!("{:#?}", txid);
    //      /////

    //     //  let serialized_psbt =  base64::encode(&serialize(&psbt));
    //     //let serialized_psbt =  base64::encode(&serialize(&psbt));

    //     // println!("{:#?}", details);
    //     // println!("{}", serialized_psbt);

    //  //   Ok()
    // }

    // pub fn sign_psbt_with_mnemonic(
    //     mnemonic: &str,
    //     mut psbt: &mut PartiallySignedTransaction
    // ) -> Result<Wallet<MemoryDatabase>, bdk::Error>{
    //     // let client = Client::new("ssl://electrum.blockstream.info:60002")?;

    //     let client = Client::new("tcp://localhost:50000")?;
    //     let blockchain = ElectrumBlockchain::from(client);
       

    //    // Parse a mnemonic
    //    let mnemonic  = Mnemonic::parse(mnemonic).unwrap();
    //    // Generate the extended key
    //    let xkey: ExtendedKey = mnemonic.into_extended_key().unwrap();
    //    // Get xprv from the extended key
    //    let xprv = xkey.into_xprv(bdk::bitcoin::Network::Regtest).unwrap();


    //     let wallet = Wallet::new(
    //         Bip84(xprv, KeychainKind::External),
    //         Some(Bip84(xprv, KeychainKind::Internal)),
    //         bdk::bitcoin::Network::Regtest,
    //         MemoryDatabase::default(),
    //     )
    //     .unwrap();
    
    //     wallet.sync(&blockchain, SyncOptions::default())?;      

    //    let sign_result = wallet.sign(&mut psbt, SignOptions::default())?;
        
    //     println!("sign_result: {:#?}", sign_result);

    //     let _psbt_is_finalized = wallet.finalize_psbt(&mut psbt, SignOptions::default())?;

    //     println!("psbt_is_finalized: {:#?}", _psbt_is_finalized);

    //     let tx = psbt.clone().extract_tx();

    //     // Broadcast the transaction using our chosen backend, returning a `Txid` or an error
       
    //     let txid =  blockchain.broadcast(&tx)?;
    //    //  println!("broadcasted txid: {:#?}", txid);

        
    
    //     Ok(wallet)
    // }